// This file was automatically generated by IDEALeek, it is not intended to be edited.

/**
 * Pistolet. 
 */
global WEAPON_PISTOL;

/**
 * Machine gun. 
 */
global WEAPON_MACHINE_GUN;

/**
 * Double gun. 
 */
global WEAPON_DOUBLE_GUN;

/**
 * Fusil à pompe. 
 */
global WEAPON_SHOTGUN;

/**
 * Magnum. 
 */
global WEAPON_MAGNUM;

/**
 * Glaive. 
 */
global WEAPON_BROADSWORD;

/**
 * Laser. 
 */
global WEAPON_LASER;

/**
 * Lance-flammes. 
 */
global WEAPON_FLAME_THROWER;

/**
 * Lance-grenades. 
 */
global WEAPON_GRENADE_LAUNCHER;

/**
 * Destroyer. 
 */
global WEAPON_DESTROYER;

/**
 * Hache. 
 */
global WEAPON_AXE;

/**
 * B-Laser. 
 */
global WEAPON_B_LASER;

/**
 * Électriseur. 
 */
global WEAPON_ELECTRISOR;

/**
 * Gazeur. 
 */
global WEAPON_GAZOR;

/**
 * Katana. 
 */
global WEAPON_KATANA;

/**
 * M-Laser. 
 */
global WEAPON_M_LASER;

/**
 * Décharge. 
 */
global CHIP_SHOCK;

/**
 * Caillou. 
 */
global CHIP_PEBBLE;

/**
 * Étincelle. 
 */
global CHIP_SPARK;

/**
 * Glaçon. 
 */
global CHIP_ICE;

/**
 * Bandage. 
 */
global CHIP_BANDAGE;

/**
 * Casque. 
 */
global CHIP_HELMET;

/**
 * Rocher. 
 */
global CHIP_ROCK;

/**
 * Guérison. 
 */
global CHIP_CURE;

/**
 * Éclair. 
 */
global CHIP_FLASH;

/**
 * Bouclier. 
 */
global CHIP_SHIELD;

/**
 * Flamme. 
 */
global CHIP_FLAME;

/**
 * Venin. 
 */
global CHIP_VENOM;

/**
 * Étirement. 
 */
global CHIP_STRETCHING;

/**
 * Bulbe Chétif. 
 */
global CHIP_PUNY_BULB;

/**
 * Protéines. 
 */
global CHIP_PROTEIN;

/**
 * Stalactite. 
 */
global CHIP_STALACTITE;

/**
 * Mur. 
 */
global CHIP_WALL;

/**
 * Bottes de cuir. 
 */
global CHIP_LEATHER_BOOTS;

/**
 * Perfusion. 
 */
global CHIP_DRIP;

/**
 * Motivation. 
 */
global CHIP_MOTIVATION;

/**
 * Toxine. 
 */
global CHIP_TOXIN;

/**
 * Éboulement. 
 */
global CHIP_ROCKFALL;

/**
 * Vaccin. 
 */
global CHIP_VACCINE;

/**
 * Tranquillisant. 
 */
global CHIP_TRANQUILIZER;

/**
 * Armure. 
 */
global CHIP_ARMOR;

/**
 * Iceberg. 
 */
global CHIP_ICEBERG;

/**
 * Blindage. 
 */
global CHIP_ARMORING;

/**
 * Libération. 
 */
global CHIP_LIBERATION;

/**
 * Solidification. 
 */
global CHIP_SOLIDIFICATION;

/**
 * Ralentissement. 
 */
global CHIP_SLOW_DOWN;

/**
 * Bulbe Rocheux. 
 */
global CHIP_ROCKY_BULB;

/**
 * Férocité. 
 */
global CHIP_FEROCITY;

/**
 * Terreau. 
 */
global CHIP_LOAM;

/**
 * Antidote. 
 */
global CHIP_ANTIDOTE;

/**
 * Rempart. 
 */
global CHIP_RAMPART;

/**
 * Fouet. 
 */
global CHIP_WHIP;

/**
 * Régénération. 
 */
global CHIP_REGENERATION;

/**
 * Réflexes. 
 */
global CHIP_REFLEXES;

/**
 * Somnifère. 
 */
global CHIP_SOPORIFIC;

/**
 * Bulbe Glacé. 
 */
global CHIP_ICED_BULB;

/**
 * Épine. 
 */
global CHIP_THORN;

/**
 * Dopage. 
 */
global CHIP_DOPING;

/**
 * Carapace. 
 */
global CHIP_CARAPACE;

/**
 * Accélération. 
 */
global CHIP_ACCELERATION;

/**
 * Inversion. 
 */
global CHIP_INVERSION;

/**
 * Boulet. 
 */
global CHIP_BALL_AND_CHAIN;

/**
 * Rage. 
 */
global CHIP_RAGE;

/**
 * Météorite. 
 */
global CHIP_METEORITE;

/**
 * Fracture. 
 */
global CHIP_FRACTURE;

/**
 * Rémission. 
 */
global CHIP_REMISSION;

/**
 * Frappe du démon. 
 */
global CHIP_DEVIL_STRIKE;

/**
 * Bulbe Guérisseur. 
 */
global CHIP_HEALER_BULB;

/**
 * Bottes de 7 lieues. 
 */
global CHIP_SEVEN_LEAGUE_BOOTS;

/**
 * Forteresse. 
 */
global CHIP_FORTRESS;

/**
 * Foudre. 
 */
global CHIP_LIGHTNING;

/**
 * Collier. 
 */
global CHIP_COLLAR;

/**
 * Bulbe Enflammé. 
 */
global CHIP_FIRE_BULB;

/**
 * Échauffement. 
 */
global CHIP_WARM_UP;

/**
 * Téléportation. 
 */
global CHIP_TELEPORTATION;

/**
 * Bottes ailées. 
 */
global CHIP_WINGED_BOOTS;

/**
 * Fertilisant. 
 */
global CHIP_FERTILIZER;

/**
 * Stéroides. 
 */
global CHIP_STEROID;

/**
 * Brûlis. 
 */
global CHIP_BURNING;

/**
 * Adrénaline. 
 */
global CHIP_ADRENALINE;

/**
 * Bulbe Métallique. 
 */
global CHIP_METALLIC_BULB;

/**
 * Écorce. 
 */
global CHIP_BARK;

/**
 * Miroir. 
 */
global CHIP_MIRROR;

/**
 * Bulbe Foudroyant. 
 */
global CHIP_LIGHTNING_BULB;

/**
 * Peste. 
 */
global CHIP_PLAGUE;

/**
 * Résurrection. 
 */
global CHIP_RESURRECTION;

/**
 * Zone circulaire de 3 cases de diamètre (croix).
 */
global AREA_CIRCLE_1 = 3;

/**
 * Zone circulaire de 5 cases de diamètre.
 */
global AREA_CIRCLE_2 = 4;

/**
 * Zone circulaire de 7 cases de diamètre.
 */
global AREA_CIRCLE_3 = 5;

/**
 * Zone d'une laser, ligne depuis la portée minimum du laser jusqu’à sa portée maximum ou bien un obstacle.
 */
global AREA_LASER_LINE = 2;

/**
 * Zone constituée d'une seule case.
 */
global AREA_POINT = 1;

/**
 * CELL_EMPTY
 */
global CELL_EMPTY = 0;

/**
 * CELL_OBSTACLE
 */
global CELL_OBSTACLE = 2;

/**
 * CELL_PLAYER
 */
global CELL_PLAYER = 1;

/**
 * Couleur bleue.
 */
global COLOR_BLUE = 255;

/**
 * Couleur verte.
 */
global COLOR_GREEN = 65280;

/**
 * Couleur rouge.
 */
global COLOR_RED = 16711680;

/**
 * Nombre d'Euler.
 */
global E = 2.71828182846;

/**
 * EFFECT_ABSOLUTE_SHIELD
 */
global EFFECT_ABSOLUTE_SHIELD = 6;

/**
 * EFFECT_AFTEREFFECT
 */
global EFFECT_AFTEREFFECT = 25;

/**
 * EFFECT_ANTIDOTE
 */
global EFFECT_ANTIDOTE = 23;

/**
 * EFFECT_BOOST_MAX_LIFE
 */
global EFFECT_BOOST_MAX_LIFE = 12;

/**
 * EFFECT_BUFF_AGILITY
 */
global EFFECT_BUFF_AGILITY = 4;

/**
 * EFFECT_BUFF_FORCE
 */
global EFFECT_BUFF_FORCE = 3;

/**
 * EFFECT_BUFF_MP
 */
global EFFECT_BUFF_MP = 7;

/**
 * EFFECT_BUFF_RESISTANCE
 */
global EFFECT_BUFF_RESISTANCE = 21;

/**
 * EFFECT_BUFF_STRENGTH
 */
global EFFECT_BUFF_STRENGTH = 3;

/**
 * EFFECT_BUFF_TP
 */
global EFFECT_BUFF_TP = 8;

/**
 * EFFECT_BUFF_WISDOM
 */
global EFFECT_BUFF_WISDOM = 22;

/**
 * EFFECT_DAMAGE
 */
global EFFECT_DAMAGE = 1;

/**
 * EFFECT_DAMAGE_RETURN
 */
global EFFECT_DAMAGE_RETURN = 20;

/**
 * EFFECT_DEBUFF
 */
global EFFECT_DEBUFF = 9;

/**
 * EFFECT_HEAL
 */
global EFFECT_HEAL = 2;

/**
 * EFFECT_INVERT
 */
global EFFECT_INVERT = 11;

/**
 * EFFECT_KILL
 */
global EFFECT_KILL = 16;

/**
 * EFFECT_POISON
 */
global EFFECT_POISON = 13;

/**
 * EFFECT_RELATIVE_SHIELD
 */
global EFFECT_RELATIVE_SHIELD = 5;

/**
 * EFFECT_RESURRECT
 */
global EFFECT_RESURRECT = 15;

/**
 * EFFECT_SHACKLE_MAGIC
 */
global EFFECT_SHACKLE_MAGIC = 24;

/**
 * EFFECT_SHACKLE_MP
 */
global EFFECT_SHACKLE_MP = 17;

/**
 * EFFECT_SHACKLE_STRENGTH
 */
global EFFECT_SHACKLE_STRENGTH = 19;

/**
 * EFFECT_SHACKLE_TP
 */
global EFFECT_SHACKLE_TP = 18;

/**
 * EFFECT_SUMMON
 */
global EFFECT_SUMMON = 14;

/**
 * EFFECT_TARGET_ALLIES
 */
global EFFECT_TARGET_ALLIES = 2;

/**
 * EFFECT_TARGET_CASTER
 */
global EFFECT_TARGET_CASTER = 4;

/**
 * EFFECT_TARGET_ENEMIES
 */
global EFFECT_TARGET_ENEMIES = 1;

/**
 * EFFECT_TARGET_NON_SUMMONS
 */
global EFFECT_TARGET_NON_SUMMONS = 8;

/**
 * EFFECT_TARGET_NOT_CASTER
 */
global EFFECT_TARGET_NOT_CASTER = 0;

/**
 * EFFECT_TARGET_SUMMONS
 */
global EFFECT_TARGET_SUMMONS = 16;

/**
 * EFFECT_TELEPORT
 */
global EFFECT_TELEPORT = 10;

/**
 * EFFECT_VULNERABILITY
 */
global EFFECT_VULNERABILITY = 26;

/**
 * Désigne une entité de type Bulbe.
 */
global ENTITY_BULB = 2;

/**
 * Désigne une entité de type Poireau.
 */
global ENTITY_LEEK = 1;

/**
 * FIGHT_CONTEXT_BATTLE_ROYALE
 */
global FIGHT_CONTEXT_BATTLE_ROYALE = 5;

/**
 * Contexte de combat de type défi.
 */
global FIGHT_CONTEXT_CHALLENGE = 1;

/**
 * Contexte de combat dans le potager.
 */
global FIGHT_CONTEXT_GARDEN = 2;

/**
 * Contexte de combat de test.
 */
global FIGHT_CONTEXT_TEST = 0;

/**
 * Contexte de combat de tournois.
 */
global FIGHT_CONTEXT_TOURNAMENT = 3;

/**
 * FIGHT_TYPE_BATTLE_ROYALE
 */
global FIGHT_TYPE_BATTLE_ROYALE = 3;

/**
 * Combat d'éleveur.
 */
global FIGHT_TYPE_FARMER = 1;

/**
 * Combat en solo.
 */
global FIGHT_TYPE_SOLO = 0;

/**
 * Combat en équipe.

 */
global FIGHT_TYPE_TEAM = 2;

/**
 * INSTRUCTIONS_LIMIT
 */
global INSTRUCTIONS_LIMIT = 300000;

/**
 * MAP_BEACH
 */
global MAP_BEACH = 6;

/**
 * MAP_DESERT
 */
global MAP_DESERT = 3;

/**
 * MAP_FACTORY
 */
global MAP_FACTORY = 2;

/**
 * MAP_FOREST
 */
global MAP_FOREST = 4;

/**
 * MAP_GLACIER
 */
global MAP_GLACIER = 5;

/**
 * MAP_NEXUS
 */
global MAP_NEXUS = 1;

/**
 * Nombre de tours maximum dans un combat.
 */
global MAX_TURNS = 64;

/**
 * MESSAGE_ATTACK
 */
global MESSAGE_ATTACK = 2;

/**
 * MESSAGE_BUFF_AGILITY
 */
global MESSAGE_BUFF_AGILITY = 8;

/**
 * MESSAGE_BUFF_FORCE
 */
global MESSAGE_BUFF_FORCE = 7;

/**
 * MESSAGE_BUFF_MP
 */
global MESSAGE_BUFF_MP = 5;

/**
 * MESSAGE_BUFF_TP
 */
global MESSAGE_BUFF_TP = 6;

/**
 * MESSAGE_CUSTOM
 */
global MESSAGE_CUSTOM = 13;

/**
 * MESSAGE_DEBUFF
 */
global MESSAGE_DEBUFF = 3
;

/**
 * MESSAGE_HEAL
 */
global MESSAGE_HEAL = 1;

/**
 * MESSAGE_MOVE_AWAY
 */
global MESSAGE_MOVE_AWAY = 10;

/**
 * MESSAGE_MOVE_AWAY_CELL
 */
global MESSAGE_MOVE_AWAY_CELL = 12;

/**
 * MESSAGE_MOVE_TOWARD
 */
global MESSAGE_MOVE_TOWARD = 9;

/**
 * MESSAGE_MOVE_TOWARD_CELL
 */
global MESSAGE_MOVE_TOWARD_CELL = 11;

/**
 * MESSAGE_SHIELD
 */
global MESSAGE_SHIELD = 4;

/**
 * Nombre d'opérations maximales qu'un poireau peut utiliser pendant son tour.
 */
global OPERATIONS_LIMIT = 20000000;

/**
 * Le rapport de la circonférence d’un cercle à son diamètre.
 */
global PI = 3.14159265359;

/**
 * Indique à la fonction #sort un tri dans l'ordre croissant.
 */
global SORT_ASC = 0;

/**
 * Indique à la fonction #sort un tri dans l'ordre décroissant.
 */
global SORT_DESC = 1;

/**
 * Type de valeur <b>tableau</b>
 */
global TYPE_ARRAY = 4;

/**
 * Type de valeur <b>booléen</b>
 */
global TYPE_BOOLEAN = 2;

/**
 * Type de valeur <b>fonction</b>
 */
global TYPE_FUNCTION = 5;

/**
 * Type de valeur <b>null</b>
 */
global TYPE_NULL = 0;

/**
 * Type de valeur <b>nombre</b>
 */
global TYPE_NUMBER = 1;

/**
 * Type de valeur <b>chaîne de caractères</b>
 */
global TYPE_STRING = 3;

/**
 * USE_CRITICAL
 */
global USE_CRITICAL = 2;

/**
 * USE_FAILED
 */
global USE_FAILED = 0;

/**
 * USE_INVALID_COOLDOWN
 */
global USE_INVALID_COOLDOWN = -3;

/**
 * USE_INVALID_POSITION
 */
global USE_INVALID_POSITION = -4;

/**
 * USE_INVALID_TARGET
 */
global USE_INVALID_TARGET = -1;

/**
 * USE_NOT_ENOUGH_TP
 */
global USE_NOT_ENOUGH_TP = -2;

/**
 * Valeur renvoyée par la fonction #resurrect lorsque l'entité spécifiée n'existe pas ou n'est pas encore morte.
 */
global USE_RESURRECT_INVALID_ENTITY = -6;

/**
 * USE_SUCCESS
 */
global USE_SUCCESS = 1;

/**
 * Erreur renvoyée par #summon lorsque vous avez déjà <b>6</b> invocations vivantes.

 */
global USE_TOO_MANY_SUMMONS = -5;

/**
 * Renvoie la valeur absolue du nombre <b>number</b>.
 * @param number Le nombre dont la valeur absolue sera calculée.
 */
function abs(number) {
}

/**
 * Calcule l'arc cosinus d'<b>argument</b>, dans l'intervalle [0, #PI].
 * @param argument Nombre dont l'arc cosinus sera calculé.
 */
function acos(argument) {
}

/**
 * Ajoute les deux tableaux bout à bout. Les clés textuelles sont conservées et toutes les clés numériques sont réindexées.
 * @param array1 Premier tableau.
 * @param array2 Second tableau.
 */
function arrayConcat(array1, array2) {
}

/**
 * Retourne un nouveau tableau contenant tous les couples clé/valeur du tableau source pour lesquels la fonction callback a renvoyé true. Si la fonction callback prend un paramètre, c'est la valeur du tableau source qui sera envoyée, si elle prend deux paramètres c'est la clé et la valeur qui seront envoyées.
 * @param array Tableau d'origine.
 * @param callback Fonction appelée pour chaque élément.
 */
function arrayFilter(array, callback) {
}

/**
 * Retourne un nouveau tableau contenant tous les éléments du tableau source. Tous les éléments contenus dans un sous tableau sont extraits dans le nouveau tableau.
<code>var tableau = [1, 2, [3, 4], 5, [6]];
debug(arrayFlatten(tableau)); // [1,2,3,4,5,6]</code>
 * @param array Tableau d'origine.
 */
function arrayFlatten(array) {
}

/**
 * Retourne un nouveau tableau contenant tous les éléments du tableau source. Tous les éléments contenus dans un sous tableau sont extraits dans le nouveau tableau.L'argument depth détermine la profondeur maximale de sous tableau à extraire.
<code>var tableau = [1, 2, [3, 4], 5, [6]];
debug(arrayFlatten(tableau)); // [1,2,3,4,5,6]</code>
 * @param array Tableau d'origine.
 * @param depth Profondeur maximale.
 */
function arrayFlatten(array, depth) {
}

/**
 * Réduit le tableau <b>array</b> [v1, v2, ..., vn] par la gauche en partant de la valeur <b>v0</b> et en appliquant la fonction <b>f</b>. Équivaut à :
<code>f(f(f(v0, v1), v2), ...)</code>
 * @param array Tableau d'origine.
 * @param f Fonction à appliquer.
 * @param v0 Valeur de départ.
 */
function arrayFoldLeft(array, f, v0) {
}

/**
 * Réduit le tableau <b>array</b> [v1, v2, ..., vn] par la droite en partant de la valeur <b>v0</b> et en appliquant la fonction <b>f</b>. Équivaut à :
<code>f(v1, f(v2, ..., f(vn, v0)))</code>.
 * @param array Tableau d'origine.
 * @param f Fonction à appliquer.
 * @param v0 Valeur de départ.
 */
function arrayFoldRight(array, f, v0) {
}

/**
 * Appelle la fonction callback pour chaque élément du tableau. Si la fonction callback prend un paramètre, c'est la valeur du tableau source qui sera envoyée, si elle prend deux paramètres c'est la clé et la valeur qui seront envoyées.
 * @param array Tableau d'origine.
 * @param callback Fonction appelée pour chaque élément.
 */
function arrayIter(array, callback) {
}

/**
 * Retourne un nouveau tableau contenant pour chaque clé du tableau source, la valeur retournée par la fonction callback. Si la fonction callback prend un paramètre, c'est la valeur du tableau source qui sera envoyée, si elle prend deux paramètres c'est la clé et la valeur qui seront envoyées.
 * @param array Tableau d'origine.
 * @param callback Fonction appelée pour chaque élément.
 */
function arrayMap(array, callback) {
}

/**
 * Retourne l'élément de valeur maximale du tableau <b>array</b>.<br/>Pour plus d'informations sur la valeur maximale d'un tableau voir #sort.
 * @param array Tableau dans lequel sera recherchée la valeur maximale.
 */
function arrayMax(array) {
}

/**
 * Retourne l'élément de valeur minimale du tableau <b>array</b>.<br/>Pour plus d'informations sur la valeur minimale d'un tableau voir #sort.
 * @param array Tableau dans lequel sera recherchée la valeur minimale.
 */
function arrayMin(array) {
}

/**
 * Retourne un nouveau tableau contenant deux listes, dans la première se trouvent tous les couples clés/valeurs pour lesquels la fonction callback a renvoyé true, dans la seconde se trouvent tous les autres. Si la fonction callback prend un paramètre, c'est la valeur du tableau source qui sera envoyée, si elle prend deux paramètres c'est la clé et la valeur qui seront envoyées.
 * @param array Tableau d'origine.
 * @param callback Fonction appelée pour chaque élément.
 */
function arrayPartition(array, callback) {
}

/**
 * Trie le tableau selon l'ordre définit par la fonction callback. Les éléments sont comparés deux à deux, la fonction callback doit renvoyer les valeurs -1, 0 ou 1 selon si la premiere valeur est avant, au même niveau ou après la seconde valeur. Si la fonction callback prend 2 paramètre, ce sont les deux valeurs qui sont envoyées, si elle en prend 4, ce sont les couples clé/valeur qui sont envoyés.
 * @param array Tableau d'origine
 * @param callback Fonction de tri.
 */
function arraySort(array, callback) {
}

/**
 * Calcule l'arc sinus d'<b>argument</b>, dans l'intervalle [0, #PI].
 * @param argument Nombre dont l'arc sinus sera calculé.
 */
function asin(argument) {
}

/**
 * Trie le tableau <b>array</b> en conservant l'association clé : valeur.
 * @param array Le tableau à trier.
 */
function assocSort(array) {
}

/**
 * Trie le tableau <b>array</b> en conservant l'association clé : valeur selon l'order <b>order</b>.
 * @param array Le tableau à trier.
 * @param order L'ordre de tri : #SORT_ASC ou #SORT_DESC.
 */
function assocSort(array, order) {
}

/**
 * Calcule l'arc tangente d'<b>argument</b>, dans l'intervalle [0, #PI].
 * @param argument Nombre dont l'arc tangente sera calculée.
 */
function atan(argument) {
}

/**
 * Convertit les coordonnées cartésiennes (<b>x</b>, <b>y</b>) en coordonnées polaires (<b>r</b>, <b>theta</b>). Cette fonction retourne l'angle <b>theta</b> entre -#PI et #PI en utilisant les signes des arguments.
 * @param y Coordonnée en y.
 * @param x Coordonnée en x.
 */
function atan2(y, x) {
}

/**
 * Calcule la moyenne des éléments contenus dans le tableau <b>array</b>.
 * @param array Tableau dont on veut calculer la moyenne.
 */
function average(array) {
}

/**
 * Détermine si votre poireau peut utiliser la puce <b>chip</b> sur le poireau d'id <b>leek</b>.
 * @param chip Le numéro de la puce à tester.
 * @param leek L'id du poireau sur lequel vous voulez utiliser la puce.
 */
function canUseChip(chip, leek) {
}

/**
 * Détermine si votre poireau peut utiliser la puce <b>chip</b> sur la cellule <b>cell</b>.
 * @param chip Le numéro de la puce à tester.
 * @param cell Le numéro de la cellule sur laquelle vous voulez utliser la puce.
 */
function canUseChipOnCell(chip, cell) {
}

/**
 * Détermine si votre poireau peut tirer sur le poireau d'id <b>leek</b> avec son arme courante.
 * @param leek L'id du poireau sur lequel vous voulez tirer.
 */
function canUseWeapon(leek) {
}

/**
 * Détermine si votre poireau peut tirer sur le poireau d'id <b>leek</b> avec l'arme <b>weapon</b>.
 * @param weapon L'arme à tester.
 * @param leek L'id du poireau sur lequel vous voulez tirer.
 */
function canUseWeapon(weapon, leek) {
}

/**
 * Détermine si votre poireau peut tirer sur la cellule <b>cell</b> avec son arme courante.
 * @param cell Le numéro de la cellule sur laquelle vous voulez tirer.
 */
function canUseWeaponOnCell(cell) {
}

/**
 * Détermine si votre poireau peut tirer sur la cellule <b>cell</b> avec l'arme <b>weapon</b>.
 * @param weapon L'arme à tester.
 * @param cell Le numéro de la cellule sur laquelle vous voulez tirer.
 */
function canUseWeaponOnCell(weapon, cell) {
}

/**
 * Calcule la racine cubique de <b>number</b>
 * @param number Nombre dont on veut calculer la racine cubique.
 */
function cbrt(number) {
}

/**
 * Retourne l'arrondi à l'entier supérieur de <b>number</b>.<br/>Vous pouvez trouver l'arrondi à l'entier inférieur avec #floor, et l'arrondi avec #round.
 * @param number Nombre dont on veut trouver l'arrondi supérieur.
 */
function ceil(number) {
}

/**
 * Retourne le caractère de la chaîne <b>string</b> situé à la position <b>position</b>.<br/>Le premier caractère de la chaîne se trouve à la position 0.
 * @param string Chaîne dont on veut récupérer un caractère.
 * @param position Position du caractère à trouver.
 */
function charAt(string, position) {
}

/**
 * Renvoie si la puce <b>chip</b> a besoin d'une ligne de vue pour être utilisée.
 * @param chip L'id de la puce à tester.
 */
function chipNeedLos(chip) {
}

/**
 * Détermine si une chaîne <b>search</b> se trouve dans une chaîne <b>string</b>.
 * @param string Chaîne dans laquelle la recherche sera effectuée.
 * @param search Chaîne à rechercher.
 */
function contains(string, search) {
}

/**
 * Calcule le cosinus de <b>angle</b>.
 * @param angle Nombre dont le cosinus sera calculé (en radians).
 */
function cos(angle) {
}

/**
 * Compte le nombre d'éléments du tableau <b>array</b>.
 * @param array Tableau dont le nombre d'éléments sera compté.
 */
function count(array) {
}

/**
 * Enregistre un message <b>object</b> dans le log personnel, disponible dans le rapport à la fin du combat.
 * @param object Le message à enregistrer.
 */
function debug(object) {
}

/**
 * Enregistre un message <b>object</b> dans le log personnel, disponible dans le rapport à la fin du combat, de la couleur <b>color</b>.
 * @param object Le message à enregistrer.
 * @param color La couleur du message. Vous pouvez utiliser la fonction #getColor.
 */
function debugC(object, color) {
}

/**
 * Enregistre un message d'erreur <b>object</b> dans le log personnel, disponible dans le rapport à la fin du combat.<br />Les messages d'erreur apparaissent en rouge dans le rapport de combat.
 * @param object Le message d'erreur à enregistrer.
 */
function debugE(object) {
}

/**
 * Enregistre un message d'avertissement <b>object</b> dans le log personnel, disponible dans le rapport à la fin du combat. <br />Les messages d'avertissement apparaissent en orange dans le rapport de combat.
 * @param object Le message d'avertissement à enregistrer.
 */
function debugW(object) {
}

/**
 * Supprime le registre associé à la clé <b>key</b> s'il existe.
 * @param key La clé du registre à supprimer.
 */
function deleteRegister(key) {
}

/**
 * Détermine si une chaîne <b>string</b> se termine par une chaîne <b>suffix</b>.
 * @param string Chaîne dans laquelle la recherche sera effectuée
 * @param suffix Suffixe à rechercher
 */
function endsWith(string, suffix) {
}

/**
 * Éleve le nombre d'Euler #E à la puissance <b>number</b>.
 * @param number L'exposant auquel #E sera élevé.
 */
function exp(number) {
}

/**
 * Remplit le tableau <b>array</b> en remplaçant chaque élément déjà existant par <b>value</b>.
 * @param array Le tableau à remplir.
 * @param value La valeur pour chaque case du tableau.
 */
function fill(array, value) {
}

/**
 * Redimensionne le tableau <b>array</b> à la taille <b>size</b> et remplit toutes ses cases avec <b>value</b>.
 * @param array Le tableau à remplir.
 * @param value La valeur pour chaque case du tableau.
 * @param size Le nombre de cases.
 */
function fill(array, value, size) {
}

/**
 * Calcule l'arrondi à l'entier inférieur de <b>number</b>.<br/>Vous pouvez trouver l'arrondi à l'entier supérieur avec #ceil, et l'arrondi avec #round.
 * @param number Nombre dont on veut trouver l'arrondi inférieur.
 */
function floor(number) {
}

/**
 * Retourne le bouclier absolu de votre poireau.
 */
function getAbsoluteShield() {
}

/**
 * Retourne le bouclier absolu du poireau d'id <b>leek</b>. Pour récupérer directement le bouclier absolu de votre poireau, utilisez #getAbsoluteShield() sans paramètre.
 * @param leek L'id du poireau dont le bouclier absolu sera retourné.
 */
function getAbsoluteShield(leek) {
}

/**
 * Retourne l'agilité de votre poireau.
 */
function getAgility() {
}

/**
 * Retourne l'agilité du poireau d'id <b>leek</b>. Pour récupérer directement l'agilité de votre poireau, utilisez #getAgility() sans paramètre.
 * @param leek L'id du poireau dont l'agilité sera retournée.
 */
function getAgility(leek) {
}

/**
 * Renvoie l'id de votre IA.
 */
function getAIID() {
}

/**
 * Renvoie l'id de l'IA du poireau <b>leek</b>.
 * @param leek L'id du poireau dont l'id d'IA sera renvoyé.
 */
function getAIID(leek) {
}

/**
 * Renvoie le nom de votre IA.
 */
function getAIName() {
}

/**
 * Renvoie le nom de l'IA du poireau <b>leek</b>.
 * @param leek L'id du poireau dont le nom d'IA sera renvoyé.
 */
function getAIName(leek) {
}

/**
 * Retourne un tableau de tous vos alliés vivants dans le combat.
 */
function getAliveAllies() {
}

/**
 * Retourne un tableau de tous vos ennemis vivants dans le combat.
 */
function getAliveEnemies() {
}

/**
 * Renvoie le nombre d'ennemis vivants dans le combat.
 */
function getAliveEnemiesCount() {
}

/**
 * Retourne un tableau contenant vos alliés, et votre poireau.
 */
function getAllies() {
}

/**
 * Renvoie le nombre d'alliés dans le combat.
 */
function getAlliesCount() {
}

/**
 * Retourne la vie totale de vos alliés.
 */
function getAlliesLife() {
}

/**
 * Renvoie le numéro du tour de combat ou vous êtes apparu. Renvoie 1 si vous êtes un poireau par exemple, et 5 si vous êtes une invocation invoquée au tour 5.
 */
function getBirthTurn() {
}

/**
 * Renvoie le tour du combat où est apparue l'entité <b>entity</b>. Renvoie 1 s'il s'agit d'un poireau par exemple, et 5 s'il d'agit d'une invocation invoquée au tour 5.
 * @param entity L'id de l'entité dont le tour d'apparition sera renvoyé.
 */
function getBirthTurn(entity) {
}

/**
 * Renvoie le taux de bleu dans la couleur <b>color</b>, entre 0 et 255. Par exemple, getBlue(#COLOR_BLUE) = 255 et getBlue(#COLOR_GREEN) = 0.
 * @param color La couleur dont le taux de bleu sera renvoyé.
 */
function getBlue(color) {
}

/**
 * Retourne la cellule où se trouve votre poireau.
 */
function getCell() {
}

/**
 * Retourne la cellule où se trouve le poireau d'id <b>leek</b>.
 * @param leek L'id du poireau dont la cellule sera retournée.
 */
function getCell(leek) {
}

/**
 * Retourne le contenu d'une cellule d'id <b>cell</b>.
 * @param cell L'id de la cellule dont le contenu sera retourné.
 */
function getCellContent(cell) {
}

/**
 * Retourne la distance entre deux cellules <b>cell1</b> et <b>cell2</b>. <br />La distance retournée est exprimée en nombre de cellules, et ne tient pas compte des divers obstacles entre les deux cellules.
Pour obtenir la distance à vol d'oiseau, voir #getDistance et pour obtenir la distance du chemin entre les deux cellules en évitant les obstacles, voir #getPathLength.
 * @param cell1 L'id de la cellule de départ.
 * @param cell2 L'id de la cellule d'arrivée.
 */
function getCellDistance(cell1, cell2) {
}

/**
 * Retourne l'id de la cellule se trouvant à la position (<b>x</b>, <b>y</b>).
 * @param x La position en x de la cellule.
 * @param y La position en y de la cellule.
 */
function getCellFromXY(x, y) {
}

/**
 * Retourne la liste des cellules à  partir desquelles votre poireau pourra utiliser la puce <b>chip</b> sur le poireau <b>leek</b>.
 * @param chip La puce que le poireau veut pouvoir utiliser.
 * @param leek Le poireau cible.
 */
function getCellsToUseChip(chip, leek) {
}

/**
 * Retourne la liste des cellules à partir desquelles votre poireau pourra utiliser la puce <b>chip</b> sur le poireau <b>leek</b>.
 * @param chip La puce que le poireau veut pouvoir utiliser.
 * @param leek Le poireau cible.
 * @param ignoredCells Tableau de cellules à ignorer.
 */
function getCellsToUseChip(chip, leek, ignoredCells) {
}

/**
 * Retourne la liste des cellules à  partir desquelles votre poireau pourra utiliser la puce <b>chip</b> sur la cellule <b>cell</b>.
 * @param chip La puce que le poireau veut pouvoir utiliser.
 * @param cell La cellule cible.
 */
function getCellsToUseChipOnCell(chip, cell) {
}

/**
 * Retourne la liste des cellules à partir desquelles votre poireau pourra utiliser la puce <b>chip</b> sur la cellule <b>cell</b>.
 * @param chip La puce que le poireau veut pouvoir utiliser.
 * @param cell La cellule cible.
 * @param ignoredCells Tableau de cellules à ignorer.
 */
function getCellsToUseChipOnCell(chip, cell, ignoredCells) {
}

/**
 * Retourne la liste des cellules à  partir desquelles votre poireau pourra utiliser son arme sur le poireau <b>leek</b>.
 * @param leek Le poireau cible.
 */
function getCellsToUseWeapon(leek) {
}

/**
 * Retourne la liste des cellules à  partir desquelles votre poireau pourra utiliser l'arme <b>weapon</b> sur le poireau <b>leek</b>.
 * @param weapon L'arme à tester.
 * @param leek Le poireau cible.
 */
function getCellsToUseWeapon(weapon, leek) {
}

/**
 * Retourne la liste des cellules à partir desquelles votre poireau pourra utiliser l'arme <b>weapon</b> sur le poireau <b>leek</b>.
 * @param weapon L'arme à tester.
 * @param leek Le poireau cible.
 * @param ignoredCells Tableau de cellules à ignorer.
 */
function getCellsToUseWeapon(weapon, leek, ignoredCells) {
}

/**
 * Retourne la liste des cellules à  partir desquelles votre poireau pourra utiliser son arme sur une cellule <b>cell</b>.
 * @param cell La cellule cible.
 */
function getCellsToUseWeaponOnCell(cell) {
}

/**
 * Retourne la liste des cellules à  partir desquelles votre poireau pourra utiliser l'arme <b>weapon</b> sur une cellule <b>cell</b>.
 * @param weapon L'arme à tester.
 * @param cell La cellule cible.
 */
function getCellsToUseWeaponOnCell(weapon, cell) {
}

/**
 * Retourne la liste des cellules à partir desquelles votre poireau pourra utiliser l'arme <b>weapon</b> sur une cellule <b>cell</b>.
 * @param weapon L'arme à tester.
 * @param cell La cellule cible.
 * @param ignoredCells Tableau de cellules à ignorer.
 */
function getCellsToUseWeaponOnCell(weapon, cell, ignoredCells) {
}

/**
 * Détermine une cellule où votre poireau pourra utiliser la puce <b>chip</b> sur le poireau <b>leek</b>.
 * @param chip La puce que le poireau veut pouvoir utiliser.
 * @param leek Le poireau cible.
 */
function getCellToUseChip(chip, leek) {
}

/**
 * Détermine une cellule où votre poireau pourra utiliser la puce <b>chip</b> sur le poireau <b>leek</b>.
 * @param chip La puce que le poireau veut pouvoir utiliser.
 * @param leek Le poireau cible.
 * @param ignoredCells Tableau de cellules à ignorer.
 */
function getCellToUseChip(chip, leek, ignoredCells) {
}

/**
 * Détermine une cellule où votre poireau pourra utiliser la puce <b>chip</b> sur la cellule <b>cell</b>.
 * @param chip La puce que le poireau veut pouvoir utiliser.
 * @param cell La cellule cible.
 * @param ignoredCells Tableau de cellules à ignorer.
 */
function getCellToUseChipOnCell(chip, cell, ignoredCells) {
}

/**
 * Détermine une cellule où votre poireau pourra utiliser la puce <b>chip</b> sur la cellule <b>cell</b>.
 * @param chip La puce que le poireau veut pouvoir utiliser.
 * @param cell La cellule cible.
 */
function getCellToUseChipOnCell(chip, cell) {
}

/**
 * Détermine une cellule où votre poireau pourra utiliser son arme sur le poireau <b>leek</b>.
 * @param leek Le poireau cible.
 */
function getCellToUseWeapon(leek) {
}

/**
 * Détermine une cellule où votre poireau pourra utiliser l'arme <b>weapon</b> sur le poireau <b>leek</b>.
 * @param weapon L'arme à tester.
 * @param leek Le poireau cible.
 */
function getCellToUseWeapon(weapon, leek) {
}

/**
 * Détermine une cellule où votre poireau pourra utiliser son arme sur le poireau <b>leek</b>.
 * @param weapon L'arme à tester.
 * @param leek Le poireau cible.
 * @param ignoredCells Tableau de cellules à ignorer.
 */
function getCellToUseWeapon(weapon, leek, ignoredCells) {
}

/**
 * Détermine une cellule où votre poireau pourra utiliser son arme sur une cellule <b>cell</b>.
 * @param cell La cellule cible.
 */
function getCellToUseWeaponOnCell(cell) {
}

/**
 * Détermine une cellule où votre poireau pourra utiliser l'arme <b>weapon</b> sur une cellule <b>cell</b>.
 * @param weapon L'arme à tester.
 * @param cell La cellule cible.
 */
function getCellToUseWeaponOnCell(weapon, cell) {
}

/**
 * Détermine une cellule où votre poireau pourra utiliser son arme sur une cellule <b>cell</b>.
 * @param weapon L'arme à tester.
 * @param cell La cellule cible.
 * @param ignoredCells Tableau de cellules à ignorer.
 */
function getCellToUseWeaponOnCell(weapon, cell, ignoredCells) {
}

/**
 * Détermine la position en X de la cellule <b>cell</b>.
 * @param cell La cellule dont la position en X sera déterminée.
 */
function getCellX(cell) {
}

/**
 * Détermine la position en Y de la cellule <b>cell</b>.
 * @param cell La cellule dont la position en Y sera déterminée.
 */
function getCellY(cell) {
}

/**
 * Renvoie le type de zone d'effet de de la puce <b>weapon</b>.
 * @param chip La puce dont le type de zone sera renvoyé.
 */
function getChipArea(chip) {
}

/**
 * Renvoie le temps de récupération de la puce <b>chip</b>, issu du marché.
 * @param chip La puce dont le cooldown sera renvoyé.
 */
function getChipCooldown(chip) {
}

/**
 * Renvoie le coût en PT de la puce <b>chip</b>.
 * @param chip La puce dont le coût sera renvoyé.
 */
function getChipCost(chip) {
}

/**
 * Renvoie la liste des cellules qui seront affectés si la puce <b>chip</b> est utilisée sur la cellule <b>cell</b>.
 * @param chip La puce à tester.
 * @param cell La cellule cible.
 */
function getChipEffectiveArea(chip, cell) {
}

/**
 * Renvoie la liste des cellules qui seront affectés si la puce <b>chip</b> est utilisée sur la cellule <b>cell</b> depuis une cellule <b>from</b>.
 * @param chip La puce à tester.
 * @param cell La cellule cible.
 * @param from La cellule depuis laquelle la puce est utilisée.
 */
function getChipEffectiveArea(chip, cell, from) {
}

/**
 * Renvoie les effets de la puce <b>chip</b>.
 * @param chip La puce dont les effets seront renvoyés.
 */
function getChipEffects(chip) {
}

/**
 * Renvoie le pourcentage de risque d'échec de la puce <b>chip</b>.
 * @param chip La puce dont le pourcentage d'échec sera renvoyé.
 */
function getChipFailure(chip) {
}

/**
 * Renvoie la portée maximale de la puce <b>chip</b>.
 * @param chip La puce dont la portée maximale sera renvoyée.
 */
function getChipMaxRange(chip) {
}

/**
 * Renvoie la portée maximale de la puce <b>chip</b>.
 * @param chip La puce dont la portée maximale sera renvoyée.
 */
function getChipMaxScope(chip) {
}

/**
 * Renvoie la portée minimale de la puce <b>chip</b>.
 * @param chip La puce dont la portée minimale sera renvoyée.
 */
function getChipMinRange(chip) {
}

/**
 * Renvoie la portée minimale de la puce <b>chip</b>.
 * @param chip La puce dont la portée minimale sera renvoyée.
 */
function getChipMinScope(chip) {
}

/**
 * Renvoie le nom de la puce <b>chip</b>.
 * @param chip La puce dont le nom sera renvoyé.
 */
function getChipName(chip) {
}

/**
 * Renvoie les puces de votre poireau.
 */
function getChips() {
}

/**
 * Renvoie les puces du poireau d'id <b>leek</b>.
 * @param leek L'id du poireau dont les puces seront renvoyées.
 */
function getChips(leek) {
}

/**
 * Renvoie les poireaux qui seront affectés si la puce <b>chip</b> est utilisée sur la cellule <b>cell</b>.
 * @param chip La puce à tester.
 * @param cell La cellule cible.
 */
function getChipTargets(chip, cell) {
}

/**
 * Retourne l'entier correspondant à la couleur (<b>red</b>, <b>green</b>, <b>blue</b>) fournie en paramètres.
 * @param red Valeur du rouge entre 0 et 255.
 * @param green Valeur du vert entre 0 et 255.
 * @param blue Valeur du bleu entre 0 et 255.
 */
function getColor(red, green, blue) {
}

/**
 * Renvoie le cooldown actuel de la puce <b>chip</b>.
 * @param chip La puce dont le cooldown actuel sera renvoyé.
 */
function getCooldown(chip) {
}

/**
 * Renvoie le cooldown actuel de la puce <b>chip</b> du poireau <b>leek</b>.
 * @param chip La puce dont le cooldown actuel sera renvoyé.
 * @param leek Le poireau dont le cooldown sera renvoyé.
 */
function getCooldown(chip, leek) {
}

/**
 * Renvoie le nombre de coeurs de votre poireau.
 */
function getCores() {
}

/**
 * Renvoie le nombre de coeurs du poireau d'id <b>leek</b>.
 * @param leek Le poireau dont le nombre de coeurs sera retournée.
 */
function getCores(leek) {
}

/**
 * Retourne le taux de renvoi de dommages de votre poireau.
 */
function getDamageReturn() {
}

/**
 * Retourne le taux de renvoi de dommages de l'entité d'id <b>leek</b>.
 * @param leek L'id de l'entité dont le renvoi de dommages sera retourné.
 */
function getDamageReturn(leek) {
}

/**
 * Renvoie les poireaux alliés morts.
 */
function getDeadAllies() {
}

/**
 * Renvoie les poireaux ennemis morts.
 */
function getDeadEnemies() {
}

/**
 * Renvoie le nombre d'ennemis morts dans le combat.
 */
function getDeadEnemiesCount() {
}

/**
 * Calcule la distance à vol d'oiseau entre deux cellules <b>cell1</b> et <b>cell2</b>. <br />Pour obtenir la distance en nombre de cellules, voir #getCellDistance, et pour obtenir la longueur du chemin entre les deux cellules en esquivant les divers obstacles, voir #getPathLength.
 * @param cell1 La cellule de départ.
 * @param cell2 La cellule d'arrivée.
 */
function getDistance(cell1, cell2) {
}

/**
 * Retourne la liste des effets de votre poireau.
 */
function getEffects() {
}

/**
 * Retourne la liste des effets du poireau d'id <b>leek</b>. Pour récupérer directement la liste des effets de votre poireau, utilisez #getEffects() sans paramètre.
 * @param leek L'id du poireau dont la liste des effets sera retourné.
 */
function getEffects(leek) {
}

/**
 * Renvoie les poireaux ennemis (vivants ou morts) dans le combat.
 */
function getEnemies() {
}

/**
 * Renvoie le nombre d'ennemis dans le combat.
 */
function getEnemiesCount() {
}

/**
 * Calcule la somme des points de vie de tous les poireaux ennemis.
 */
function getEnemiesLife() {
}

/**
 * Retourne une valeur entre 1 et n (nombre d'entités actuellement en jeu) indiquant la position de l'entité actuelle dans l'ordre de jeu.
 */
function getEntityTurnOrder() {
}

/**
 * Retourne une valeur entre 1 et n (nombre d'entités actuellement en jeu) indiquant la position de l'entité <b>entity</b> dans l'ordre de jeu.
 * @param entity L'id de l'entité dont l'ordre de jeu sera renvoyé
 */
function getEntityTurnOrder(entity) {
}

/**
 * Renvoie votre pays.
 */
function getFarmerCountry() {
}

/**
 * Renvoie le pays de l'éleveur du poireau <b>leek</b>.
 * @param leek L'id du poireau dont le pays de d'éleveur sera renvoyé.
 */
function getFarmerCountry(leek) {
}

/**
 * Renvoie votre id d'éleveur.
 */
function getFarmerID() {
}

/**
 * Renvoie l'id de l'éleveur du poireau <b>leek</b>.
 * @param leek L'id du poireau dont l'id d'éleveur sera renvoyé.
 */
function getFarmerID(leek) {
}

/**
 * Renvoie le nom de votre éleveur.
 */
function getFarmerName() {
}

/**
 * Renvoie le nom de l'éleveur du poireau <b>leek</b>.
 * @param leek L'id du poireau dont le nom d'éleveur sera renvoyé.
 */
function getFarmerName(leek) {
}

/**
 * Détermine l'allié le plus éloigné de votre poireau, à vol d'oiseau.
 */
function getFarthestAlly() {
}

/**
 * Détermine l'ennemi le plus éloigné de votre poireau, à vol d'oiseau.
 */
function getFarthestEnemy() {
}

/**
 * Retourne le contexte du combat actuel.
 */
function getFightContext() {
}

/**
 * Retourne le type de combat actuel.
 */
function getFightType() {
}

/**
 * Renvoie la force de votre poireau.
 */
function getForce() {
}

/**
 * Renvoie la force du poireau d'id <b>leek</b>.
 * @param leek Le poireau dont la force sera retournée.
 */
function getForce(leek) {
}

/**
 * Renvoie la fréquence de votre poireau.
 */
function getFrequency() {
}

/**
 * Renvoie la fréquence du poireau d'id <b>leek</b>.
 * @param leek Le poireau dont la fréquence sera retournée.
 */
function getFrequency(leek) {
}

/**
 * Renvoie le taux de vert dans la couleur <b>color</b>, entre 0 et 255. Par exemple, getGreen(#COLOR_GREEN) = 255 et getGreen(#COLOR_RED) = 0.
 * @param color La couleur dont le taux de vert sera renvoyé.
 */
function getGreen(color) {
}

/**
 * Renvoie le nombre d'instructions que votre poireau a effectué durant le tour actuel.
 */
function getInstructionsCount() {
}

/**
 * Renvoie la liste des effets qu'a provoqué votre poireau.
 */
function getLaunchedEffects() {
}

/**
 * Renvoie la liste des effets qu'a provoqué l'entité d'id <b>leek</b>.
 * @param leek L'id de l'entité dont la liste des effets provoqués sera retournée.
 */
function getLaunchedEffects(leek) {
}

/**
 * Renvoie l'id de votre poireau.
 */
function getLeek() {
}

/**
 * Renvoie l'id réel de votre poireau.
 */
function getLeekID() {
}

/**
 * Renvoie l'id réel du poireau d'id <b>leek</b>.
 * @param leek L'id du poireau dont l'id réel sera retourné.
 */
function getLeekID(leek) {
}

/**
 * Renvoie le poireau qui se trouve sur la cellule <b>cell</b>.
 * @param cell La cellule dont on veut récupérer le poireau.
 */
function getLeekOnCell(cell) {
}

/**
 * Renvoie le niveau de votre poireau.
 */
function getLevel() {
}

/**
 * Renvoie le niveau du poireau d'id <b>leek</b>.
 * @param leek L'id du poireau dont le niveau sera renvoyé.
 */
function getLevel(leek) {
}

/**
 * Renvoie la vie actuelle de votre poireau.
 */
function getLife() {
}

/**
 * Renvoie la vie actuelle du poireau d'id <b>leek</b>.
 * @param leek L'id du poireau dont la vie sera renvoyée.
 */
function getLife(leek) {
}

/**
 * Renvoie la magie de votre poireau.
 */
function getMagic() {
}

/**
 * Renvoie la magie de l'entité d'id <b>leek</b>.
 * @param leek L'id de l'entité dont la magie sera retournée.
 */
function getMagic(leek) {
}

/**
 * Renvoie le type de terrain sur lequel se déroule le combat (usine, désert, forêt etc.), parmi les constantes #MAP_NEXUS, #MAP_FACTORY, #MAP_DESERT, #MAP_FOREST, #MAP_GLACIER et #MAP_BEACH.
 */
function getMapType() {
}

/**
 * Renvoie l'id du poireau auteur du message <b>message</b>.
 * @param message Le message dont l'auteur sera renvoyé.
 */
function getMessageAuthor(message) {
}

/**
 * Renvoie le tableau des paramètres du message <b>message</b>.
 * @param message Le message dont les paramètres seront renvoyés.
 */
function getMessageParams(message) {
}

/**
 * Renvoie le tableau de vos messages.
 */
function getMessages() {
}

/**
 * Renvoie le tableau des messages du poireau <b>leek</b>.
 * @param leek Le poireau dont les messages seront renvoyés.
 */
function getMessages(leek) {
}

/**
 * Renvoie le type du message <b>message</b>.
 * @param message Le message dont le type sera renvoyé (parmis #MESSAGE_HEAL, #MESSAGE_ATTACK, etc.).
 */
function getMessageType(message) {
}

/**
 * Revoie le nombre de points de mouvements actuel de votre poireau.
 */
function getMP() {
}

/**
 * Revoie le nombre de points de mouvements actuel du poireau <b>leek</b>.
 * @param leek L'id du poireau dont le nombre de PM sera renvoyé.
 */
function getMP(leek) {
}

/**
 * Renvoie le nom de votre poireau.
 */
function getName() {
}

/**
 * Renvoie le nom du poireau d'id <b>leek</b>.
 * @param leek L'id du poireau dont le nom sera renvoyé.
 */
function getName(leek) {
}

/**
 * Renvoie le poireau allié le plus proche de votre poireau.
 */
function getNearestAlly() {
}

/**
 * Renvoie le poireau allié le plus proche du poireau fourni en paramètre.
 * @param leek L'id du poireau dont on veut connaitre l'allié le plus proche.
 */
function getNearestAllyTo(leek) {
}

/**
 * Renvoie le poireau allié le plus proche de la cellule fournie en paramètre.
 * @param cell L'id de la cellule dont on veut connaitre l'allié le plus proche.
 */
function getNearestAllyToCell(cell) {
}

/**
 * Renvoie le poireau ennemi le plus proche de votre poireau.
 */
function getNearestEnemy() {
}

/**
 * Renvoie le poireau ennemi le plus proche du poireau fourni en paramètre.
 * @param leek L'id du poireau dont on veut connaitre l'ennemi le plus proche.
 */
function getNearestEnemyTo(leek) {
}

/**
 * Renvoie le poireau ennemi le plus proche de la cellule fournie en paramètre.
 * @param cell L'id de la cellule dont on veut connaitre l'ennemi le plus proche.
 */
function getNearestEnemyToCell(cell) {
}

/**
 * Renvoie l'id du poireau qui jouera après le joueur actuel.
 */
function getNextPlayer() {
}

/**
 * Renvoie la liste des cases obstacles du terrain.
 */
function getObstacles() {
}

/**
 * Renvoie le nombre d'opérations consommées par votre poireau depuis le début de son tour. Ce nombre doit rester inférieur à #OPERATIONS_LIMIT pour ne pas que le poireau plante.
 */
function getOperations() {
}

/**
 * Renvoie le chemin en évitant les obstacles entre deux cellules <b>cell1</b> et <b>cell2</b>, si celui-ci existe.
 * @param cell1 La cellule de départ.
 * @param cell2 La cellule d'arrivée.
 */
function getPath(cell1, cell2) {
}

/**
 * Renvoie le chemin en évitant les obstacles entre deux cellules <b>cell1</b> et <b>cell2</b>, si celui-ci existe, en ignorant les cellules contenues dans le tableau <b>ignoredCells</b>. Si un joueur se situe sur une cellule ignorée, le chemin peut passer sur lui.
 * @param start La cellule de départ.
 * @param end La cellule d'arrivée.
 * @param ignoredCells Le tableau des cellules à ignorer.
 */
function getPath(start, end, ignoredCells) {
}

/**
 * Renvoie la longueur du chemin entre deux cellules <b>cell1</b> et <b>cell2</b>, en esquivant les obstacles. Cette fonction équivaut à <i>count(getPath(<b>cell1</b>, <b>cell2</b>))</i>.<br /><br />
Pour obtenir la distance à vol d'oiseau, utilisez #getDistance, et pour obtenir la distance entre deux cellules sans tenir compte des obstacles, utilisez #getCellDistance.
 * @param cell1 La cellule de départ.
 * @param cell2 La cellule d'arrivée.
 */
function getPathLength(cell1, cell2) {
}

/**
 * Renvoie la longueur du chemin entre deux cellules <b>cell1</b> et <b>cell2</b>, en esquivant les obstacles, en ignorant les cellules contenues dans le tableau <b>ignoredCells</b>.
Si un joueur se situe sur une cellule ignorée, le chemin peut passer sur lui.
 * @param cell1 La cellule de départ.
 * @param cell2 La cellule d'arrivée.
 * @param ignoredCells Le tableau des cellules à ignorer.
 */
function getPathLength(cell1, cell2, ignoredCells) {
}

/**
 * Renvoie l'id du poireau ayant joué avant le joueur actuel.
 */
function getPreviousPlayer() {
}

/**
 * Renvoie le taux de rouge dans la couleur <b>color</b>, entre 0 et 255. Par exemple, getRed(#COLOR_RED) = 255 et getRed(#COLOR_BLUE) = 0.
 * @param color La couleur dont le taux de rouge sera renvoyé.
 */
function getRed(color) {
}

/**
 * Renvoie la valeur stockée dans le registre du poireau associé à la clé <b>key</b> ou </i>null</i> si le registre n'existe pas.
 * @param key La clé du registre dont la valeur sera retournée.
 */
function getRegister(key) {
}

/**
 * Renvoie l'ensemble des registres du poireau sous la forme d'un tableau associatif [<i>clé du registre</i> : <i>valeur du registre</i>]. Exemple : <code>debug(getRegisters());
// Affiche par exemple :
// ['reg1' : '314323', 'reg2' : 'test_string']</code>
 */
function getRegisters() {
}

/**
 * Retourne le bouclier relatif de votre poireau.
 */
function getRelativeShield() {
}

/**
 * Retourne le bouclier relatif du poireau d'id <b>leek</b>. Pour récupérer directement le bouclier relatif de votre poireau, utilisez #getRelativeShield() sans paramètre.
 * @param leek L'id du poireau dont le bouclier relatif sera retourné.
 */
function getRelativeShield(leek) {
}

/**
 * Renvoie la résistance de votre poireau.
 */
function getResistance() {
}

/**
 * Renvoie la résistance de l'entité d'id <b>leek</b>.
 * @param leek L'id de l'entité dont la résistance sera retournée.
 */
function getResistance(leek) {
}

/**
 * Renvoie la science de votre poireau.
 */
function getScience() {
}

/**
 * Renvoie la science de l'entité d'id <b>leek</b>.
 * @param leek L'id de l'entité dont la science sera retournée.
 */
function getScience(leek) {
}

/**
 * Renvoie la force de votre poireau.
 */
function getStrength() {
}

/**
 * Renvoie la force du poireau d'id <b>leek</b>.
 * @param leek Le poireau dont la force sera retournée.
 */
function getStrength(leek) {
}

/**
 * Renvoie l'entité qui vous a invoqué, si vous êtes une invocation.
 */
function getSummoner() {
}

/**
 * Renvoie l'entité a invoqué l'entité <b>entity</b>, s'il s'agit d'une invocation.
 * @param entity L'id de l'entité dont l'invocateur sera renvoyé.
 */
function getSummoner(entity) {
}

/**
 * Renvoie l'id de votre équipe.
 */
function getTeamID() {
}

/**
 * Renvoie l'id de l'équipe du poireau <b>leek</b>.
 * @param leek L'id du poireau dont l'id d'équipe sera renvoyé.
 */
function getTeamID(leek) {
}

/**
 * Renvoie le nom de votre équipe.
 */
function getTeamName() {
}

/**
 * Renvoie le nom de l'équipe du poireau <b>leek</b>.
 * @param leek L'id du poireau dont le nom d'équipe sera renvoyé.
 */
function getTeamName(leek) {
}

/**
 * Renvoie la vie totale de votre poireau.
 */
function getTotalLife() {
}

/**
 * Renvoie la vie totale du poireau d'id <b>leek</b>.
 * @param leek L'id du poireau dont la vie totale sera retournée.
 */
function getTotalLife(leek) {
}

/**
 * Renvoie le nombre maximal de points de mouvement de votre poireau.
 */
function getTotalMP() {
}

/**
 * Renvoie le nombre maximal de points de mouvement de l'entité <b>leek</b>.
 * @param leek L'id de l'entité dont le le nombre maximal de points de mouvement sera retourné.
 */
function getTotalMP(leek) {
}

/**
 * Renvoie le nombre maximal de points de tour de votre poireau.
 */
function getTotalTP() {
}

/**
 * Renvoie le nombre maximal de points de tour de l'entité <b>leek</b>.
 * @param leek L'id de l'entité dont le le nombre maximal de points de tour sera retourné.
 */
function getTotalTP(leek) {
}

/**
 * Renvoie le nombre de points de tour de votre poireau.
 */
function getTP() {
}

/**
 * Renvoie le nombre de points de tour du poireau <b>leek</b>.
 * @param leek L'id du poireau dont les PT seront renvoyés.
 */
function getTP(leek) {
}

/**
 * Renvoie le tour actuel du combat. Le nombre de tours maximum est #MAX_TURNS.
 */
function getTurn() {
}

/**
 * Renvoie votre type d'entité.
 */
function getType() {
}

/**
 * Renvoie le type d'entité de l'entité <b>entity</b>.
 * @param entity L'id de l'entité dont le type sera renvoyé.
 */
function getType(entity) {
}

/**
 * Renvoie l'arme actuellement équipée sur votre poireau.
 */
function getWeapon() {
}

/**
 * Renvoie l'arme actuellement équipée le poireau <b>leek</b>.
 * @param leek L'id du poireau dont l'arme actuelle sera renvoyée.
 */
function getWeapon(leek) {
}

/**
 * Renvoie le type de zone d'effet de l'arme <b>weapon</b>.
 * @param weapon L'arme dont le type de zone sera renvoyé.
 */
function getWeaponArea(weapon) {
}

/**
 * Renvoie le coût en PT de l'arme <b>weapon</b>.
 * @param weapon L'id de l'arme dont le coût sera renvoyé.
 */
function getWeaponCost(weapon) {
}

/**
 * Renvoie la liste des cellules qui seront affectées si l'arme courante est utilisée sur la cellule <b>cell</b>.
 * @param cell La cellule cible.
 */
function getWeaponEffectiveArea(cell) {
}

/**
 * Renvoie la liste des cellules qui seront affectées si l'arme <b>weapon</b> est utilisée sur la cellule <b>cell</b>.
 * @param weapon L'arme à tester.
 * @param cell La cellule cible.
 */
function getWeaponEffectiveArea(weapon, cell) {
}

/**
 * Renvoie la liste des cellules qui seront affectées si l'arme <b>weapon</b> est utilisée sur la cellule <b>cell</b> depuis la cellule <b>from</b>.
 * @param weapon L'arme à tester.
 * @param cell La cellule cible.
 * @param from La cellule depuis laquelle l'arme est utilisée.
 */
function getWeaponEffectiveArea(weapon, cell, from) {
}

/**
 * Renvoie les effets de l'arme <b>weapon</b>.
 * @param weapon L'id de l'arme dont les effets seront retournés.
 */
function getWeaponEffects(weapon) {
}

/**
 * Renvoie le pourcentage de risque d'échec de l'arme <b>weapon</b>.
 * @param weapon L'id de l'arme dont le pourcentage d'échec sera renvoyé.
 */
function getWeaponFailure(weapon) {
}

/**
 * Renvoie la portée maximale de l'arme <b>weapon</b>.
 * @param weapon L'id de l'arme dont la portée maximale sera renvoyée.
 */
function getWeaponMaxRange(weapon) {
}

/**
 * Renvoie la portée maximale de l'arme <b>weapon</b>.
 * @param weapon L'id de l'arme dont la portée maximale sera renvoyée.
 */
function getWeaponMaxScope(weapon) {
}

/**
 * Renvoie la portée minimale de l'arme <b>weapon</b>.
 * @param weapon L'id de l'arme dont la portée minimale sera renvoyée.
 */
function getWeaponMinRange(weapon) {
}

/**
 * Renvoie la portée minimale de l'arme <b>weapon</b>.
 * @param weapon L'id de l'arme dont la portée minimale sera renvoyée.
 */
function getWeaponMinScope(weapon) {
}

/**
 * Renvoie le nom de l'arme <b>weapon</b>.
 * @param weapon L'id de l'arme dont le nom sera renvoyé.
 */
function getWeaponName(weapon) {
}

/**
 * Renvoie les armes de votre poireau.
 */
function getWeapons() {
}

/**
 * Renvoie les armes du poireau d'id <b>leek</b>.
 * @param leek L'id du poireau dont les armes seront renvoyées.
 */
function getWeapons(leek) {
}

/**
 * Renvoie les poireaux qui seront affectés si l'arme courante est utilisée sur la cellule <b>cell</b>.
 * @param cell La cellule cible.
 */
function getWeaponTargets(cell) {
}

/**
 * Renvoie les poireaux qui seront affectés si l'arme <b>weapon</b> est utilisée sur la cellule <b>cell</b>.
 * @param weapon L'arme à tester.
 * @param cell La cellule cible.
 */
function getWeaponTargets(weapon, cell) {
}

/**
 * Renvoie la sagesse de votre poireau.
 */
function getWisdom() {
}

/**
 * Renvoie la sagesse de l'entité d'id <b>leek</b>.
 * @param leek L'id de l'entité dont la sagesse sera retournée.
 */
function getWisdom(leek) {
}

/**
 * Renvoie l'hypoténuse du triangle rectangle de côtés x et y. Équivaut à <i>sqrt(x**2&nbsp;+&nbsp;y**2)</i>.
 * @param x La valeur x.
 * @param y La valeur y.
 */
function hypot(x, y) {
}

/**
 * Détermine si l'élément <b>element</b> est dans le tableau <b>array</b>.
 * @param array Le tableau de recherche.
 * @param element L'élément à rechercher.
 */
function inArray(array, element) {
}

/**
 * Inclut l'IA de nom <b>ai</b> dans l'IA courante. <br><br><b>Attention</b>, la fonction include doit être appelée uniquement dans le bloc principal, et son paramètre doit être une chaîne écrite directement
dans le code. Pour plus d'informations, voir la section dans le tutoriel : <a href='http://leekwars.com/tutorial#includes'>http://leekwars.com/tutorial#includes</a>.
 * @param ai Le nom de l'IA à inclure.
 */
function include(ai) {
}

/**
 * Détermine la position de la première occurrence de la chaîne <b>search</b> dans la chaîne <b>string</b>.
 * @param string La chaîne où la recherche sera effectuée.
 * @param search La chaîne à rechercher.
 */
function indexOf(string, search) {
}

/**
 * Détermine la position de la première occurrence de la chaîne <b>search</b> dans la chaîne <b>string</b>, à partir de la position <b>start</b>.
 * @param string La chaîne où la recherche sera effectuée.
 * @param search La chaîne à rechercher.
 * @param start La position de départ de la recherche.
 */
function indexOf(string, search, start) {
}

/**
 * Insère un élément <b>element</b> dans le tableau <b>array</b> à la position <b>position</b>.
 * @param array Le tableau où l'élément sera inséré.
 * @param element L'élément à insérer.
 * @param position La position de l'insertion.
 */
function insert(array, element, position) {
}

/**
 * Détermine si un poireau <b>leek</b> est vivant. Équivalent à <i>getLife(<b>leek</b>) > 0</i>.
 * @param leek L'id du poireau à tester.
 */
function isAlive(leek) {
}

/**
 * Détermine si le poireau <b>leek</b> est votre allié.
 * @param leek L'id du poireau à tester.
 */
function isAlly(leek) {
}

/**
 * Détermine si une valeur est une constante représentant une puce.<br><br>isChip(CHIP_RAGE) = true;<br>isChip(WEAPON_PISTOL) = false.
 * @param value Le nombre à déterminer.
 */
function isChip(value) {
}

/**
 * Détermine si le poireau <b>leek</b> est mort. Équivalent à <i>getLife(<b>leek</b>) == 0</i>.
 * @param leek L'id du poireau à tester.
 */
function isDead(leek) {
}

/**
 * Détermine si le tableau <b>array</b> est vide. Équivalent à <i>count(<b>array</b>) == 0</i>.
 * @param array Le tableau à tester.
 */
function isEmpty(array) {
}

/**
 * Détermine si une cellule est vide.
 * @param cell La cellule à tester.
 */
function isEmptyCell(cell) {
}

/**
 * Détermine si le poireau <b>leek</b> est votre ennemi.
 * @param leek L'id du poireau à tester.
 */
function isEnemy(leek) {
}

/**
 * Détermine si la puce <b>chip</b> peut être utlisée uniquement en ligne.
 * @param chip L'id de la puce à tester.
 */
function isInlineChip(chip) {
}

/**
 * Détermine si l'arme <b>weapon</b> peut être utlisée uniquement en ligne.
 * @param weapon L'id de l'arme à tester.
 */
function isInlineWeapon(weapon) {
}

/**
 * Détermine si le contenu de la cellule <b>cell</b> est un poireau.
 * @param cell La cellule à tester.
 */
function isLeek(cell) {
}

/**
 * Détermine si le contenu de la cellule <b>cell</b> est un obstacle.
 * @param cell La cellule à tester.
 */
function isObstacle(cell) {
}

/**
 * Détermine si deux cellules <b>cell1</b> et <b>cell2</b> sont sur la même ligne.
 * @param cell1 La première cellule.
 * @param cell2 La deuxième cellule.
 */
function isOnSameLine(cell1, cell2) {
}

/**
 * Renvoie si vous êtes une invocation ou non.
 */
function isSummon() {
}

/**
 * Renvoie si l'entité <b>entity</b> est une invocation ou non.
 * @param entity L'id de l'entité à tester.
 */
function isSummon(entity) {
}

/**
 * Détermine si une valeur est une constante représentant une arme.<br><br>isWeapon(WEAPON_LASER) = true;<br>isWeapon(CHIP_TELEPORTATION) = false.
 * @param value Le nombre à déterminer.
 */
function isWeapon(value) {
}

/**
 * Fusionne plusieurs éléments en une chaîne de caractères, en les séparant par un délimiteur <b>glue</b>.
 * @param array Un tableau d'éléments à fusionner.
 * @param glue Le délimiteur des éléments.
 */
function join(array, glue) {
}

/**
 * Décode la chaîne <b>json</b> en objet LeekScript (nombre, chaîne, tableau...).
 * @param json La chaîne JSON à décoder.
 */
function jsonDecode(json) {
}

/**
 * Encode l'objet <b>object</b> en chaîne JSON.
 * @param object L'objet à encoder en JSON.
 */
function jsonEncode(object) {
}

/**
 * Trie le tableau <b>array</b> selon les clés.
 * @param array Le tableau à trier.
 */
function keySort(array) {
}

/**
 * Trie le tableau <b>array</b> selon les clés selon l'ordre <b>order</b>.
 * @param array Le tableau à trier.
 * @param order L'ordre de tri : #SORT_ASC ou #SORT_DESC.
 */
function keySort(array, order) {
}

/**
 * Renvoie la longueur de la chaîne <b>string</b>.
 * @param string La chaîne dont la longueur sera retournée.
 */
function length(string) {
}

/**
 * Vérifie la ligne de vue entre la cellule <b>start</b> et la cellule <b>end</b>.
 * @param start Cellule de départ.
 * @param end Cellule cible.
 */
function lineOfSight(start, end) {
}

/**
 * Vérifie la ligne de vue entre la cellule <b>start</b> et la cellule <b>end</b>, en ignorant le poireau <b>leek</b>.
 * @param start Cellule de départ.
 * @param end Cellule cible.
 * @param leekToIgnore Le poireau à ignorer.
 */
function lineOfSight(start, end, leekToIgnore) {
}

/**
 * Renvoie le tableau des say() des poireaux précédents, sous la forme [leek_id, message].
 */
function listen() {
}

/**
 * Calcule le logarithme néperien du nombre <b>number</b>.
 * @param number Un nombre compris dans l'intervalle ]0; +∞[.
 */
function log(number) {
}

/**
 * Calcule le logarithme en base 10 du nombre <b>number</b>.
 * @param number Un nombre compris dans l'intervalle ]0; +∞[.
 */
function log10(number) {
}

/**
 * Marque une ou plusieurs cellules en noir sur le terrain pour 1 tour. Ce marquage n'est visible que par l'éleveur du poireau.
 * @param cells La cellule ou tableau de plusieurs cellules à marquer
 */
function mark(cells) {
}

/**
 * Marque une ou plusieurs cellules de la couleur indiquée en paramètre sur le terrain pour 1 tour. Ce marquage n'est visible que par l'éleveur du poireau.
 * @param cells La cellule ou tableau de plusieurs cellules à marquer
 * @param color Couleur du marquage
 */
function mark(cells, color) {
}

/**
 * Marque une ou plusieurs cellules de la couleur indiquée en paramètre sur le terrain pour le nombre de tour indiqué en paramètre. Ce marquage n'est visible que par l'éleveur du poireau.
 * @param cells La cellule ou tableau de plusieurs cellules à marquer
 * @param color Couleur du marquage
 * @param duration Durée du marquage
 */
function mark(cells, color, duration) {
}

/**
 * Renvoie le plus grande valeur entre les deux nombres <b>a</b> et <b>b</b>.
 * @param a Un nombre.
 * @param b Un nombre.
 */
function max(a, b) {
}

/**
 * Renvoie la plus petite valeur entre les deux nombres <b>a</b> et <b>b</b>.
 * @param a Un nombre.
 * @param b Un nombre.
 */
function min(a, b) {
}

/**
 * Éloigne votre poireau d'un autre poireau <b>leek</b>.
 * @param leek Le poireau dont votre poireau doit s'éloigner.
 */
function moveAwayFrom(leek) {
}

/**
 * Éloigne votre poireau d'un autre poireau <b>leek</b>, en utilisant au maximum <b>mp</b> points de mouvement.
 * @param leek Le poireau dont votre poireau doit s'éloigner.
 * @param mp Le nombre maximum de PM à utiliser.
 */
function moveAwayFrom(leek, mp) {
}

/**
 * Éloigne votre poireau d'une cellule <b>cell</b>.
 * @param cell La cellule dont votre poireau doit s'éloigner.
 */
function moveAwayFromCell(cell) {
}

/**
 * Éloigne votre poireau d'une cellule <b>cell</b>, en utilisant au maximum <b>mp</b> points de mouvement.
 * @param cell La cellule dont votre poireau doit s'éloigner.
 * @param mp Le nombre maximum de PM à utiliser.
 */
function moveAwayFromCell(cell, mp) {
}

/**
 * Éloigne votre poireau d'un ensemble de cellules <b>cells</b>.
 * @param cells Le tableau contenant les cellules dont votre poireau doit s'éloigner.
 */
function moveAwayFromCells(cells) {
}

/**
 * Éloigne votre poireau d'un ensemble de cellules <b>cells</b>, en utilisant au maximum <b>mp</b> points de mouvement.
 * @param cells Le tableau contenant les cellules dont votre poireau doit s'éloigner.
 * @param mp Le nombre maximum de PM à utiliser.
 */
function moveAwayFromCells(cells, mp) {
}

/**
 * Éloigne votre poireau d'un ensemble de poireaux <b>leeks</b>.
 * @param leeks Le tableau contenant les ids des poireaux dont votre poireau doit s'éloigner.
 */
function moveAwayFromLeeks(leeks) {
}

/**
 * Éloigne votre poireau d'un ensemble de poireaux <b>leeks</b>, en utilisant au maximum <b>mp</b> points de mouvement.
 * @param leeks Le tableau contenant les ids des poireaux dont votre poireau doit s'éloigner.
 * @param mp Le nombre maximum de PM à utiliser.
 */
function moveAwayFromLeeks(leeks, mp) {
}

/**
 * Éloigne votre poireau d'une ligne définie par deux cellules <b>cell1</b> et <b>cell2</b>.
 * @param cell1 La cellule 1.
 * @param cell2 La cellule 2.
 */
function moveAwayFromLine(cell1, cell2) {
}

/**
 * Éloigne votre poireau d'une ligne définie par deux cellules <b>cell1</b> et <b>cell2</b>, en utilisant au maximum <b>mp</b> points de mouvement.
 * @param cell1 La cellule 1.
 * @param cell2 La cellule 2.
 * @param mp Le nombre maximum de PM à utiliser.
 */
function moveAwayFromLine(cell1, cell2, mp) {
}

/**
 * Rapproche votre poireau d'un autre poireau <b>leek</b>.
 * @param leek Le poireau vers lequel votre poireau doit se rapprocher.
 */
function moveToward(leek) {
}

/**
 * Rapproche votre poireau d'un autre poireau <b>leek</b>, en utilisant au maximum <b>mp</b> points de mouvement.
 * @param leek Le poireau vers lequel votre poireau doit se rapprocher.
 * @param mp Le nombre maximum de PM à utiliser.
 */
function moveToward(leek, mp) {
}

/**
 * Rapproche votre poireau d'une cellule <b>cell</b>.
 * @param cell La cellule vers laquelle votre poireau doit se rapprocher.
 */
function moveTowardCell(cell) {
}

/**
 * Rapproche votre poireau d'une cellule <b>cell</b>, en utilisant au maximum <b>mp</b> points de mouvement.
 * @param cell La cellule vers laquelle votre poireau doit se rapprocher.
 * @param mp Le nombre maximum de PM à utiliser.
 */
function moveTowardCell(cell, mp) {
}

/**
 * Rapproche votre poireau d'un ensemble de cellules <b>cells</b>.
 * @param cells Le tableau contenant les cellules vers lesquelles votre poireau doit se rapprocher.
 */
function moveTowardCells(cells) {
}

/**
 * Rapproche votre poireau d'un ensemble de cellules <b>cells</b>, en utilisant au maximum <b>mp</b> points de mouvement.
 * @param cells Le tableau contenant les cellules vers lesquelles votre poireau doit se rapprocher.
 * @param mp Le nombre maximum de PM à utiliser.
 */
function moveTowardCells(cells, mp) {
}

/**
 * Rapproche votre poireau d'un ensemble de poireaux <b>leeks</b>.
 * @param leeks Le tableau contenant les ids des poireaux vers lesquels votre poireau doit se rapprocher.
 */
function moveTowardLeeks(leeks) {
}

/**
 * Rapproche votre poireau d'un ensemble de poireaux <b>leeks</b>, en utilisant au maximum <b>mp</b> points de mouvement.
 * @param leeks Le tableau contenant les ids des poireaux vers lesquels votre poireau doit se rapprocher.
 * @param mp Le nombre maximum de PM à utiliser.
 */
function moveTowardLeeks(leeks, mp) {
}

/**
 * Rapproche votre poireau d'une ligne définie par deux cellules <b>cell1</b> et <b>cell2</b>.
 * @param cell1 La cellule 1.
 * @param cell2 La cellule 2.
 */
function moveTowardLine(cell1, cell2) {
}

/**
 * Rapproche votre poireau d'une ligne définie par deux cellules <b>cell1</b> et <b>cell2</b>, en utilisant au maximum <b>mp</b> points de mouvement.
 * @param cell1 La cellule 1.
 * @param cell2 La cellule 2.
 * @param mp Le nombre maximum de PM à utiliser.
 */
function moveTowardLine(cell1, cell2, mp) {
}

/**
 * Convertit une valeur en nombre. Si la valeur est une chaîne, la fonction number va essayer de la convertir en nombre, si la valeur est déjà un nombre, la fonction renvoie le nombre, et pour tout autre type, elle renvoie <i>null</i>.
 * @param value La valeur à convertir en nombre.
 */
function number(value) {
}

/**
 * Met en pause le combat, uniquement pour l'éleveur du poireau qui utilise la fonction.
 */
function pause() {
}

/**
 * Supprime la dernière case du tableau <b>array</b> et renvoie l'élément correspondant.
 * @param array Le tableau dont la dernière case sera supprimée.
 */
function pop(array) {
}

/**
 * Éleve le nombre base à la puissance exposant.
 * @param base La base.
 * @param exp L'exposant.
 */
function pow(base, exp) {
}

/**
 * Ajoute l'élément <b>element</b> à la fin du tableau <b>array</b>.
 * @param array Le tableau où l'on veut ajouter l'élément.
 * @param element L'élément à ajouter.
 */
function push(array, element) {
}

/**
 * Ajoute tous les éléments du tableau <b>elements</b> à la fin du tableau <b>array</b>.
 * @param array Le tableau où l'on veut ajouter les éléments.
 * @param elements Les éléments à ajouter.
 */
function pushAll(array, elements) {
}

/**
 * Renvoie un nombre aléatoire réel, compris entre 0 (inclus) et 1 (exclu).
 */
function rand() {
}

/**
 * Renvoie un nombre aléatoire réel, compris entre <b>a</b> (inclus) et <b>b</b> (exclu).
 * @param a Borne inférieure.
 * @param b Borne supérieure.
 */
function randFloat(a, b) {
}

/**
 * Renvoie un nombre aléatoire entier, compris entre <b>a</b> (inclus) et <b>b</b> (exclu).
 * @param a Borne inférieure.
 * @param b Borne supérieure.
 */
function randInt(a, b) {
}

/**
 * Supprime un élément du tableau <b>array</b> à la position <b>position</b>, et retourne l'élément supprimé.
 * @param array Tableau dont on veut supprimer un élément.
 * @param position Position de l'élément à supprimer.
 */
function remove(array, position) {
}

/**
 * Supprime la première occurrence d'un élément <b>element</b> dans le tableau <b>array</b>. Si l'élement n'est pas trouvé, le tableau n'est pas modifié.
 * @param array Tableau dont on veut supprimer un élément.
 * @param element Élement à rechercher puis à supprimer.
 */
function removeElement(array, element) {
}

/**
 * Supprime un élément du tableau <b>array</b> associé à la clé <b>key</b>.
 * @param array Tableau dont on veut supprimer un élément.
 * @param key La clé associée à l'élément à supprimer.
 */
function removeKey(array, key) {
}

/**
 * Remplace toutes les occurrences de <b>search</b> par <b>replace</b> dans la chaîne <b>string</b>.
 * @param string Chaîne dans laquelle les remplacements sont effectués.
 * @param search Sous-chaîne à remplacer.
 * @param replace Chaîne de remplacement.
 */
function replace(string, search, replace) {
}

/**
 * Utilise la puce CHIP_RESURRECTION pour ressusciter une entité d'id <b>entity</b> morte, sur la cellule <b>cell</b>.
 * @param entity L'id de l'entité à faire revivre.
 * @param cell La cellule sur laquelle l'entité réapparaîtra.
 */
function resurrect(entity, cell) {
}

/**
 * Inverse le tableau <b>array</b>.
 * @param array Tableau à inverser.
 */
function reverse(array) {
}

/**
 * Retourne l'arrondi de <b>number</b>.<br/>Vous pouvez trouver l'arrondi à l'entier inférieur avec #floor, et l'arrondi à l'entier supérieur avec #ceil.
 * @param number Nombre dont on veut trouver l'arrondi.
 */
function round(number) {
}

/**
 * Fait parler votre poireau.
 * @param message Message qu'annonçera votre poireau dans l'arène.
 */
function say(message) {
}

/**
 * Recherche l'élément <b>element</b> dans le tableau <b>array</b>.
 * @param array Le tableau de recherche.
 * @param element L'élément à rechercher.
 */
function search(array, element) {
}

/**
 * Recherche l'élément <b>element</b> dans le tableau <b>array</b>, à partir de la position <b>start</b>.
 * @param array Le tableau de recherche.
 * @param element L'élément à rechercher.
 * @param start La position du début de la recherche.
 */
function search(array, element, start) {
}

/**
 * Envoie un message à toute votre équipe.
 * @param type Le type du message à envoyer (voir les constantes MESSAGE_*).
 * @param params Les paramètres du message, qui peuvent être n'importe quelle valeur.
 */
function sendAll(type, params) {
}

/**
 * Envoie un message au poireau d'id <b>leek</b>.
 * @param leek L'id du poireau auquel sera envoyé le message.
 * @param type Le type du message à envoyer (voir les constantes MESSAGE_*).
 * @param params Les paramètres du message, qui peuvent être n'importe quelle valeur.
 */
function sendTo(leek, type, params) {
}

/**
 * Stocke la valeur <b>value</b> dans le registre de clé <b>key</b>.
La clé et la valeur sont des chaînes qui doivent contenir
respectivement <i>100</i> et <i>5000</i> caractères au maximum. Un
poireau peut posséder au maximum <i>100</i> registres, le stockage
dans un nouveau registre ne fonctionnera pas si tous les registres
sont déjà occupés.
 * @param key La clé du registre où stocker la valeur.
 * @param value La valeur à stocker.
 */
function setRegister(key, value) {
}

/**
 * Équipe l'arme <b>weapon</b> sur votre poireau.
 * @param weapon Id de l'arme à équiper.
 */
function setWeapon(weapon) {
}

/**
 * Supprime la première case du tableau <b>array</b> et renvoie l'élément correspondant.
 * @param array Le tableau dont la première case sera supprimée.
 */
function shift(array) {
}

/**
 * Montre aux joueurs une cellule <b>cell</b> en noir sur le terrain pour 1 tour. L'utilisation de cette fonction coûte 1PT.
 * @param cell La cellule à montrer
 */
function show(cell) {
}

/**
 * Montre aux joueurs une cellule <b>cell</b> de la couleur <b>color</b> sur le terrain pour 1 tour. L'utilisation de cette fonction coûte 1PT.
 * @param cell La cellule à montrer
 * @param color Couleur du marquage
 */
function show(cell, color) {
}

/**
 * Mélange un tableau de manière aléatoire.
 * @param array Le tableau à mélanger.
 */
function shuffle(array) {
}

/**
 * Détermine le signe du nombre <b>number</b>.
 * @param number Le nombre dont le signe sera déterminé.
 */
function signum(number) {
}

/**
 * Calcule le sinus de l'angle <b>angle</b> passé en paramètre
 * @param angle L'angle dont le sinus sera calculé
 */
function sin(angle) {
}

/**
 * Trie le tableau <b>array</b> selon l'ordre suivant :
<ul>
	<li>Tous les booléens (d'abord faux puis vrais)</li>
	<li>Tous les nombres (classés du plus petit au plus grand)</li>
	<li>Toutes les chaînes (dans l'ordre alphabétique)</li>
	<li>Tous les éléments null.</li>
</ul>
 * @param array Tableau à trier.
 */
function sort(array) {
}

/**
 * Trie le tableau <b>array</b> par ordre croissant ou décroissant. Voir #sort pour l'ordre de tri.
 * @param array Tableau à trier.
 * @param order #SORT_ASC pour trier <b>array</b> dans l'ordre croissant ou #SORT_DESC pour le trier dans l'ordre décroissant.
 */
function sort(array, order) {
}

/**
 * Découpe la chaîne <b>string</b> sous-chaînes en délimitées par <b>delimiter</b>.
 * @param string Chaîne à découper.
 * @param delimiter Chaîne délimitant le passage d'un élément à un autre.
 */
function split(string, delimiter) {
}

/**
 * Découpe la chaîne <b>string</b> sous-chaînes en délimitées par <b>delimiter</b>.
 * @param string Chaîne à découper.
 * @param delimiter Chaîne délimitant le passage d'un élément à un autre.
 * @param limit Nombre d'éléments maximum du tableau.
 */
function split(string, delimiter, limit) {
}

/**
 * Calcule la racine carrée du nombre <b>number</b>.
 * @param number Nombre dont la racine sera calculée.
 */
function sqrt(number) {
}

/**
 * Vérifie si la chaîne <b>string</b> commence par la chaîne <b>prefix</b>.
 * @param string Chaîne de recherche.
 * @param prefix Préfixe recherché.
 */
function startsWith(string, prefix) {
}

/**
 * Convertit une valeur en chaîne de caractères.<br>
Si la valeur est déjà une chaîne, elle est renvoyée.<br>
Si la valeur est nombre x, "x" est renvoyé.<br>
Si la valeur est un tableau, une chaîne sous la forme "[clé1 : valeur1, clé2 : valeur2, ...]" est renvoyée.<br>
Si la valeur est un booléen, "true" et "false" sont respectivement renvoyées pour les valeurs true et false.<br>
Si la valeur est null, "null" est renvoyée.
 * @param value La valeur à convertir en chaîne de caractères.
 */
function string(value) {
}

/**
 * Retourne un sous-tableau de <b>array</b> commençant à la position <b>start</b> et finissant à la position <b>end</b>.
 * @param array Tableau source.
 * @param start Indice de départ.
 * @param end Indice de fin.
 */
function subArray(array, start, end) {
}

/**
 * Retourne la sous-chaîne de la chaîne <b>string</b> à partir du caractère à l'indice <b>start</b>.
 * @param string Chaîne source.
 * @param start Indice du caractère de départ.
 */
function substring(string, start) {
}

/**
 * Retourne la sous-chaîne de la chaîne <b>string</b> à partir du caractère à l'indice <b>start</b> et de taille <b>length</b>.
 * @param string Chaîne à découper.
 * @param start Indice du caractère de départ.
 * @param length Longueur de la sous-chaîne.
 */
function substring(string, start, length) {
}

/**
 * Retourne la somme de tous les éléments numériques du tableau <b>array</b>.
 * @param array Tableau à sommer.
 */
function sum(array) {
}

/**
 * Invoque une entité déterminée par la puce <b>chip</b> sur la cellule <b>cell</b> ayant pour IA la fonction <b>ai</b>.
 * @param chip La puce utilisée pour l'invocation. La puce doit être une puce de type invocation et doit être équipée sur le poireau qui utilise la fonction summon.
 * @param cell La cellule ou l'invocation doit apparaître.
 * @param ai L'IA de l'invocation, sous la forme d'une fonction.
 */
function summon(chip, cell, ai) {
}

/**
 * Calcule la tangente de l'angle <b>angle</b> (en radians).
 * @param angle Angle en radians.
 */
function tan(angle) {
}

/**
 * Convertit l'angle <b>radians</b> en degrés.
 * @param radians Valeur en radians
 */
function toDegrees(radians) {
}

/**
 * Convertit les caractères majuscules de la chaîne <b>string</b> en minuscules.
 * @param string Chaîne à transformer
 */
function toLower(string) {
}

/**
 * Convertit l'angle <b>degrees</b> en radians.
 * @param degrees Valeur en degrés
 */
function toRadians(degrees) {
}

/**
 * Convertit les caractères minuscules de la chaîne <b>string</b> par des majuscules.
 * @param string Chaîne à transformer.
 */
function toUpper(string) {
}

/**
 * Renvoie le type de la valeur <b>value</b>, parmis les types : #TYPE_NULL, #TYPE_NUMBER, #TYPE_BOOLEAN, #TYPE_STRING, #TYPE_ARRAY, #TYPE_FUNCTION.
 * @param value La valeur dont le type sera retourné.
 */
function typeOf(value) {
}

/**
 * Ajoute l'élément <b>element</b> au début du tableau <b>array</b>.
 * @param array Tableau dans lequel l'élément sera ajouté.
 * @param element Element à ajouter.
 */
function unshift(array, element) {
}

/**
 * Utilise le chip <b>chip</b> sur le poireau <b>leek</b>.
 * @param chip Chip à utiliser.
 * @param leek Poireau cible.
 */
function useChip(chip, leek) {
}

/**
 * Utilise le chip <b>chip</b> sur la cellule <b>cell</b>.
 * @param chip Chip à utiliser.
 * @param cell Cellule cible.
 */
function useChipOnCell(chip, cell) {
}

/**
 * Utilise l'arme sélectionnée sur le poireau <b>leek</b>.
 * @param leek Poireau ciblé.
 */
function useWeapon(leek) {
}

/**
 * Utilise l'arme sélectionnée sur la cellule <b>cell</b>.
 * @param cell Cellule ciblée.
 */
function useWeaponOnCell(cell) {
}

/**
 * Renvoie si l'arme <b>weapon</b> a besoin d'une ligne de vue pour tirer.
 */
function weaponNeedLos() {
}

/**
 * ${fun.description}
 * @param weapon $param.value
 */
function weaponNeedLos(weapon) {
}

